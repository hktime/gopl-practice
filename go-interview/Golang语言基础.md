Go面试问的问题也很有限嘛，channel、协程调度模型、切片底层、读写锁，也可能让你介绍一下GC、三色标记算法

1、空struct{}是否使用过？会在什么情况下使用，举例说明一下。 2、在Go语言中，结构体是否能够比较？该如何比较两个结构体？如何比较两个接口？可以顺便查考一下代码实现。 3、使用Go语言编程实现堆栈和队列这两个数据结构，该如何实现。可以只说实现思路。 4、var a []int和a := []int{}是否有区别？如果有的话，具体有什么区别？在开发过程中使用哪个更好，为什么？ 5、Go中，如何复制切片内容？如何复制map内容？如何复制接口内容？编程时会如何操作实现。

什么是goroutine，他与process， thread有什么区别？2. 什么是channel，为什么它可以做到线程安全？3. 了解读写锁吗，原理是什么样的，为什么可以做到？4. 如何用channel实现一个令牌桶？5. 如何调试一个go程序？6. 如何写单元测试和基准测试？7. goroutine 的调度是怎样的？8. golang 的内存回收是如何做到的？9. cap和len分别获取的是什么？10. netgo，cgo有什么区别？11. 什么是interface？

# Array和slice 或者 数组与切片 的联系与区别

## 数组
数组是一个由**固定**长度的特定类型元素组成的序列。
* 数组是不可变的。
* 数组的长度是**数组类型**的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。
* 数组的长度必须是**常量**表达式，因为数组的长度需要在编译阶段确定。

## 切片
切片代表变长的序列，序列中每个元素都有相同的类型，写作[]T。
* 切片是可变的，没有固定长度。
* slice由三部分构成：指针、长度和容量，指针指向第一个slice元素对应的底层数组元素的地址。
* 和数组不同的是，slice之间不能比较，不能用==操作符判断两个slice是否含有全部相等元素。

切片不支持==操作的原因：
1. 一个slice的元素是间接引用的，一个slice甚至可以包含自身。缺乏一个简单有效的方法处理这种情形。举例：s := []interface{}{"one", nil}; s[1] = s;
2. 因为slice的元素是间接引用的，一个固定的slice值在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。安全起见。slice可以与nil比较。

### append操作
先判断slice底层数组是否有足够的容量来保存新添加的元素。
1. 如果有，直接拓展slice（依然在原有的底层数组之上），将新元素添加到新拓展的空间，并返回slice。输入的x和输出的z共享相同的底层数组。

2. 如果没有，先**分配**一个足够大的slice用于保存新的结果，先将输入的x**复制**到新的空间，然后添加y元素。结果z和输入的x引用的是不同的底层数组。

拓展数组时长度直接翻倍。

### 比较两个slice是否相等
参考[比较两个slice是否相等](https://www.jianshu.com/p/80f5f5173fca)
参考[golang中判断两个slice是否相等](https://www.cnblogs.com/apocelipes/p/11116725.html)

* 判断两个[]byte是否相等
使用系统函数bytes.Equal()
```
return bytes.Equal(a, b)
```
* reflect
使用reflect.DeepEqual()函数：
```
func StringSliceReflectEqual(a, b []string) bool {
    return reflect.DeepEqual(a, b)
}
```
* 循环遍历比较
手动实现，比reflect快
```
func StringSliceEqual(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }

    if (a == nil) != (b == nil) {
        return false
    }

    for i, v := range a {
        if v != b[i] {
            return false
        }
    }

    return true
}
```

# 结构体 struct

## 空结构体的作用
参考[空结构体struct{}解析](https://cloud.tencent.com/developer/article/1068400)
空结构体写作struct{}，大小为0，也不包含任何信息，有时候依然是有价值的。在用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性。但是因为节约的空间有限，而且语法比较复杂，所以通常避免这样的用法。
```
seen := make(map[string]struct{})
if _, ok := seen[s]; !ok{
    seen[s] = struct{}{}
}
```
## 结构体的比较
如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员。
```
type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}
// 两种比较方式是等价的：
fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
fmt.Println(p == q)                   // "false"
```

# 常用关键字
## defer
1. defer关键字的调用时机以及多次调用defer时的执行顺序；


2. defer关键字使用传值的方式传递参数时

# 接口
接口的值由两个部分组成，一个具体的类型和那个类型的值。被称为接口的动态类型和动态值。
在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值,就是它的类型和值的部分都是nil。

## 接口的比较
接口值可以使用==或!=来进行比较。两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用做map的键或者switch语句的操作数。

然而，如果两个接口值的动态类型相同，但是该类型是不可比较的（比如切片），将他们进行比较就会失败并且panic。

# 变量
## 变量的声明
变量声明的一般语法如下：

```var 变量名字 类型 = 表达式```

其中“类型”或“= 表达式”两个部分可以省略其中的一个，如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。

简短变量声明如下：

```名字 := 表达式```
被用于大部分局部变量的声明和初始化。

## var a []int和a := []int{}是否有区别
var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

简短声明的限制是不能提供数据类型，而且只能用在函数内部。

## make和new
1. make的作用是初始化内置的数据结构；
2. new的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针。


# 内存分配
编程语言的内存分配器一般包含两种分配方法，一种是线性分配器，另一种是空闲链表分配器。

## 线性分配器
一种高效的内存分配方式，但有较大的局限性。只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域，并修改指针在内存中的位置。

具有较快的执行速度，以及较低的实现复杂度，但是线性分配器无法在内存被释放时重用内存。需要配合具有拷贝特性的垃圾回收算法。

## 空闲链表分配器
可以重用已经被释放的内存，在内部会维护一个类似链表的数据结构，当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表。

## 分级分配
go语言的内存分配核心理念是利用多级缓存将对象根据大小分配，并按照类别实施不同的分配策略。
### 对象大小
类别|大小|
---|---|
微对象|0-16B|
小对象|16B-32KB|
大对象|32KB-+∞|

### 虚拟内存布局
1.10以前的版本，堆区的内存空间都是连续的，但是在1.11版本，使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。

# 垃圾回收
三色标记算法，将程序中的对象分为白色、黑色和灰色三类：
* 白色对象 - 潜在的垃圾，其内存可能会被垃圾收集器回收；
* 黑色对象 - 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
* 灰色对象 - 活跃的对象，存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。

工作原理：
1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述步骤直到对象图中不存在灰色对象，只剩下黑色的存活对象和白色的垃圾对象，垃圾回收器可以回收白色的垃圾。



