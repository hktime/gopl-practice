## 操作系统相关

### 进程和线程区别
线程依赖于进程而存在，一个进程至少有一个线程。
1. 拥有资源

* 进程有自己的独立地址空间，线程共享所属进程的地址空间；
* 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，
* 只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；

2. 调度

* 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置；
* 而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
* 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，而不同进程中的线程切换，则会引起进程的切换。

3. 系统开销

由于创建或撤销进程时，系统都要为他分配或回收资源，所付出的开销远大于创建或撤销线程时的开销。线程切换时只需保存或设置少量寄存器的内容，开销远小于进程切换。

4. 通信

* 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，
* 而进程之间的通信需要以进程间通信(IPC)的方式进行；

5. 健壮性

* 多线程程序只要有一个线程崩溃，整个程序就崩溃了，
* 但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。

### 同一进程中的线程可以共享哪些数据？独享哪些数据？
1. 共享数据

堆、地址空间、全局变量等。

2. 独享数据

栈和程序计数器，用来保存线程的执行历史和状态，一组寄存器。

### 线程间通信和进程间通信（IPC）
1. 线程间通信

和进程相比，线程的最大优点之一是数据的共享性，各个进程共享父进程的地址空间。这也给多线程编程带来了许多问题，常用的线程间通信方式有互斥锁（Mutex）和信号量（SEM）。

2. 进程间通信

进程通信是一种手段，而进程同步是一种目的。可以通过进程通信的方法来达到进程同步的目的。

* 管道

通过调用pipe函数创建的。具有以下限制：只支持半双工通信（单向交替传输），只能在父子进程或者兄弟进程中使用。

* 命名管道（FIFO）

去除了管道只能用在父子进程中使用的限制。

* 消息队列

可以独立于读写进程存在，避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。

读进程可以根据消息类型有选择地接受信息，而不像FIFO只能默认的接收。

克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

* 信号量

计数器，用于为多个进程提供对共享数据对象的访问。

* 共享内存

允许多个进程共享一个给定的内存，数据不需要在进程之间复制，所以是最快的一种IPC。

* 套接字

用于不同机器间的进程通信。

## 数据结构
### 链表和数组
1. 增删改查的区别

* 数组

主要看数组是否有序以及是否知道下标。

增加：对于插入操作，有序数组时间复杂度为O(N)，因为需要把比插入数大的都往后移；

删除：对于删除操作，需要先找到该数，时间复杂度为O(logN)，其次再删除该数，该数后面的数全部都往前移动。因此总过程的时间复杂度为O(N)；

修改：同删除操作，修改需要先找到该数，因为此数组有序，所以还得移动该数，使数组恢复有序。因此时间复杂度为O(N)；

查找：因为该数组有序，因此可以用二分法查找，时间复杂度为O(logN)。如果通过索引查找，时间复杂度为O(1)。

* 链表

增加：链表是通过记录头部地址来进行寻找后面数值的，所以需要遍历链表操作，如果在头部增，只需要查找一次，时间复杂度为O(1)，在尾部增需要查找n此，时间复杂度为O(N)；

删除：要遍历找到想要删除的链表，平均查找次数为n/2，时间复杂度为O(N)；

修改：要遍历找到想要更改的数值，同样只能遍历查找，平均查找次数为n/2，时间复杂度为O(N)；

查找：平均查找次数为n/2，时间复杂度为O(N)。

## 计算机网络
### TCP包最大大小，切包和黏包

1. 最大大小

MTU泛指通讯协议中的最大通信单元，一般用来说明TCP/IP四层协议中数据链路层的最大传输单元，普遍使用的以太网的MTU是1500

2. 黏包

黏包指的是在socket通信过程中，如果通信的一端一次性连续发送多条数据包，tcp协议会将多个数据包打包成一个tcp报文发送出去，这就是所谓的黏包。

总结出现粘包的原因：

* 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去；
* 接收数据端的应用层没有及时读取接收缓冲区中的数据；
* 数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去(如果客户端每发送一条数据就睡眠一段时间就不会发生粘包)；

3. 切包

切包指的是通信的一段发送的数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个tcp报文分开传输，这就叫拆包。

## 算法
### 二分查找
1. 循环解法：
```
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return -1
}
```

2. 查找左边界
```
func binarySearchLeftBorder(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            right = mid
        } else if nums[mid] > target {
            right = mid
        } else {
            left = mid + 1
        }
    }
    if left >= len(nums) {
        return -1
    }
    if nums[left] != target {
        return -1
    }
    return left
}
```

3. 查找右边界
```
func binarySearchRightBorder(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid
        } else {
            left = mid + 1
        }
    }
    if left == 0 {
        return -1
    }
    if nums[left-1] != target {
        return -1
    }
    return left - 1
}
```

## golang相关

### golang实现单例模式

1. 懒汉方式
```
1 type singleton struct{}
2 var ins *singleton
3 func GetIns() *singleton{
4     if ins == nil {
5     　　ins = &singleton{}
6     }
7     return ins
8 }
```

2. 加锁
```
 1 type singleton struct{}
 2 var ins *singleton
 3 var mu sync.Mutex
 4 func GetIns() *singleton{
 5     mu.Lock()
 6     defer mu.Unlock()
 7 
 8     if ins == nil {
 9     　　ins = &singleton{}
10     }
11     return ins
12 }
```