## 测试相关
### 测试用例
1. 测试用例设计的方法

等价类划分法和边界值分析法。

* 等价类划分法

就是把输入域的可输入值进行等价性划分，然后在每一个等价域中取少量的能代表这个等价域的值作为测试用例的输入数据。根据每个等价类值是否对程序有作用，分为有效等价类和无效等价类。

有效等价类：此类中的值对于执行用例的程序来说是有意义且合理的，可以有效的检验程序是否实现了需求规格说明中规定的功能。

无效等价类：此类中的值正好相反，对程序来说是不合理的、无意义的，输入此类中的值程序无法实现相应的功能和性能，但是从程序的健壮性来考虑，程序也应该对此类中的值做出正确的反应。

* 边界值分析法

一般用于对等价类划分法完成之后作补充，因为程序的很多错误都是发生在输入或者输出的范围边界上的，而不是在输入范围的内部。

所谓的边界是指输入域中，稍高于地域边界值的一些特定情况，特别是要考虑空值时的测试情况。

2. 测试用例的组成元素

* 用例编号
* 用例标题
* 功能模块名称
* 前置条件
* 输入数据
* 操作步骤
* 预期结果
* 优先级
* 执行结果
* 编写人
* 执行人

### 接口测试
1. 什么是接口测试

接口即通常所说的API（应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定，用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码。

也就是将一些复杂的操作封装起来方便其他程序调用，调用的形式可以是本地函数，也可以是网络请求，而通常说的接口测试大都是基于HTTP协议的api接口。

2. 接口文档

应该包含以下内容：
* 接口说明
* 调用url
* 请求方法（get/post）
* 请求参数、参数类型、请求参数说明
* 返回参数说明

3. 接口测试方法

![接口测试](https://ask.qcloudimg.com/http-save/yehe-2035292/7zydivevta.jpeg?imageView2/2/w/1620)

postman


## CI/CD什么含义

怎么实现

## linux
### shell脚本调用方式
三种调用方式，分别是（fork，exec，source）

1. fork(/path/to/script.sh)
fork是最普通的，运行的时候开一个sub-shell执行调用的脚本，此时parent-shell还在。

2. exec(exec /path/to/script.sh)
不需要另开一个sub-shell来执行被调用的脚本，父脚本和被调用的脚本在同一个shell内执行，但是使用exec调用一个新脚本以后，父脚本中exec行之后的内容就不会再执行了。也就是exec和source的区别。

3. source(source /path/to/script.sh)
也是不需要新开一个sub-shell来执行被调用的脚本，执行子脚本后继续执行父脚本，同时子脚本设置的环境变量会影响到父级的环境变量。

Linux命令相关，统计文本行数命令，查找匹配文件

数据库，drop、truncate和delete区别，修改一个字段名

网络，get和post区别，响应状态码

测试用例设计

## 操作系统相关

### 进程和线程区别
线程依赖于进程而存在，一个进程至少有一个线程。
1. 拥有资源

* 进程有自己的独立地址空间，线程共享所属进程的地址空间；
* 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，
* 只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；

2. 调度

* 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置；
* 而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
* 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，而不同进程中的线程切换，则会引起进程的切换。

3. 系统开销

由于创建或撤销进程时，系统都要为他分配或回收资源，所付出的开销远大于创建或撤销线程时的开销。线程切换时只需保存或设置少量寄存器的内容，开销远小于进程切换。

4. 通信

* 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，
* 而进程之间的通信需要以进程间通信(IPC)的方式进行；

5. 健壮性

* 多线程程序只要有一个线程崩溃，整个程序就崩溃了，
* 但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。

### 同一进程中的线程可以共享哪些数据？独享哪些数据？
1. 共享数据

堆、地址空间、全局变量等。

2. 独享数据

栈和程序计数器，用来保存线程的执行历史和状态，一组寄存器。

### 线程间通信和进程间通信（IPC）
1. 线程间通信

和进程相比，线程的最大优点之一是数据的共享性，各个进程共享父进程的地址空间。这也给多线程编程带来了许多问题，常用的线程间通信方式有互斥锁（Mutex）和信号量（SEM）。

2. 进程间通信

进程通信是一种手段，而进程同步是一种目的。可以通过进程通信的方法来达到进程同步的目的。

* 管道

通过调用pipe函数创建的。具有以下限制：只支持半双工通信（单向交替传输），只能在父子进程或者兄弟进程中使用。

* 命名管道（FIFO）

去除了管道只能用在父子进程中使用的限制。

* 消息队列

可以独立于读写进程存在，避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法。

读进程可以根据消息类型有选择地接受信息，而不像FIFO只能默认的接收。

克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

* 信号量

计数器，用于为多个进程提供对共享数据对象的访问。

* 共享内存

允许多个进程共享一个给定的内存，数据不需要在进程之间复制，所以是最快的一种IPC。

* 套接字

用于不同机器间的进程通信。

## 数据结构
### 链表和数组
1. 增删改查的区别

* 数组

主要看数组是否有序以及是否知道下标。

增加：对于插入操作，有序数组时间复杂度为O(N)，因为需要把比插入数大的都往后移；

删除：对于删除操作，需要先找到该数，时间复杂度为O(logN)，其次再删除该数，该数后面的数全部都往前移动。因此总过程的时间复杂度为O(N)；

修改：同删除操作，修改需要先找到该数，因为此数组有序，所以还得移动该数，使数组恢复有序。因此时间复杂度为O(N)；

查找：因为该数组有序，因此可以用二分法查找，时间复杂度为O(logN)。如果通过索引查找，时间复杂度为O(1)。

* 链表

增加：链表是通过记录头部地址来进行寻找后面数值的，所以需要遍历链表操作，如果在头部增，只需要查找一次，时间复杂度为O(1)，在尾部增需要查找n此，时间复杂度为O(N)；

删除：要遍历找到想要删除的链表，平均查找次数为n/2，时间复杂度为O(N)；

修改：要遍历找到想要更改的数值，同样只能遍历查找，平均查找次数为n/2，时间复杂度为O(N)；

查找：平均查找次数为n/2，时间复杂度为O(N)。

## 计算机网络
### TCP包最大大小，切包和黏包

1. 最大大小

MTU泛指通讯协议中的最大通信单元，一般用来说明TCP/IP四层协议中数据链路层的最大传输单元，普遍使用的以太网的MTU是1500

2. 黏包

黏包指的是在socket通信过程中，如果通信的一端一次性连续发送多条数据包，tcp协议会将多个数据包打包成一个tcp报文发送出去，这就是所谓的黏包。

总结出现粘包的原因：

* 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去；
* 接收数据端的应用层没有及时读取接收缓冲区中的数据；
* 数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去(如果客户端每发送一条数据就睡眠一段时间就不会发生粘包)；

3. 切包

切包指的是通信的一段发送的数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个tcp报文分开传输，这就叫拆包。

## 算法
### 二分查找
1. 循环解法：
```
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return -1
}
```

2. 查找左边界
```
func binarySearchLeftBorder(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            right = mid
        } else if nums[mid] > target {
            right = mid
        } else {
            left = mid + 1
        }
    }
    if left >= len(nums) {
        return -1
    }
    if nums[left] != target {
        return -1
    }
    return left
}
```

3. 查找右边界
```
func binarySearchRightBorder(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid
        } else {
            left = mid + 1
        }
    }
    if left == 0 {
        return -1
    }
    if nums[left-1] != target {
        return -1
    }
    return left - 1
}
```

## golang相关

### golang实现单例模式

1. 懒汉方式
```
1 type singleton struct{}
2 var ins *singleton
3 func GetIns() *singleton{
4     if ins == nil {
5     　　ins = &singleton{}
6     }
7     return ins
8 }
```

2. 加锁
```
 1 type singleton struct{}
 2 var ins *singleton
 3 var mu sync.Mutex
 4 func GetIns() *singleton{
 5     mu.Lock()
 6     defer mu.Unlock()
 7 
 8     if ins == nil {
 9     　　ins = &singleton{}
10     }
11     return ins
12 }
```