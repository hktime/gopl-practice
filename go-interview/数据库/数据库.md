## 事务
### 概念
事务指的是满足ACID特性的一组操作，可以通过Commit提交一个事务，也可以使用Rollback进行回滚。

### ACID
1. 原子性（Atomicity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

回滚可以用回滚日志(Undo log)来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. 一致性（Consistency）

数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

3. 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其他事务是不可见的。

4. 持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存在数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。

系统发生崩溃可以用重做日志（Redo log）进行恢复。

## 并发一致性问题
### 丢失修改
指一个事务的更新操作被另外一个事务的更新操作替换。

### 读脏数据
指在不同的事务下，当前事务可以读到另外事务未提交的数据。

### 不可重复读
指在同一个事务内多次读取同一数据集合，在这一事务还未结束前，另一事务也访问了该数据集合并做了修改，由于第二个事务的修改，第一个事务的多次读取的数据可能不一样。

### 幻读
本质上也属于不可重复读的情况，T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同。

区别在于幻读前后多次读取，数据总量不一致。也就是加行级锁的情况，其他事务不能修改，但可以进行插入。

这些并发不一致的问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性，并发控制可以通过锁来实现。

## 锁
### 封锁粒度
根据封锁粒度可以分为：行级锁和表级锁两种。

并发程度，应该尽可能只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越小，发生锁争用的可能就越小，系统的并发程度就越高。

锁开销，加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统开销就越大。

在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。

### 封锁类型
根据封锁类型可以分为，乐观锁和悲观锁

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

悲观锁：假设会发生并发冲突，在进行每次操作前都要通过获取锁才能进行对相同数据的操作。

悲观锁根据实现不同，又可以分为互斥锁（写锁）和共享锁（读锁）。

互斥锁，其他事务不能读也不能写；共享锁，其他事务可以并发读但不能写。


## 隔离级别
锁需要用户自己操作，比较复杂，数据管理系统提供了更简单的隔离级别操作。

### 未提交读
事务中的修改，即使没有提交，对其他事务也是可见的。

### 提交读
一个事务只能读取已经提交的事务所做的修改，事务在没有提交前的修改对其他事务是不可见的。

### 可重复读
保证在同一个事务中多次读取同一数据的结果是一样的。

### 可串行化
强制事务串行执行，多个事务互不干扰，不会出现并发一致性问题。该隔离等级需要加锁实现，保证同一时间只有一个事务执行，也就是保证事务串行执行。

![隔离级别能解决的并发一致性问题](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png)

## 多版本并发控制（MVCC）
InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。
### 基本思想
加锁能解决多个事务同时执行时出现的并发一致性问题。MVCC利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。

在MVCC中事务的修改操作（delete、insert、update）会为数据行新增一个版本快照。

通过保存数据在某个时间点的快照来实现的。InnoDB中的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的创建时间，一个保存行的过期时间。储存的并不是实际时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

### 具体操作
在可重复读隔离级别下，MVCC的具体操作：

* SELECT：根据以下两个条件检查每行记录，1. InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。2. 行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除。

* INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

* DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

* UPDATE：InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

保留两个额外系统版本号，使大多数读操作都不用加锁，使得读操作简单且性能良好，并且能保证只读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

## 三范式
1. 第一范式

数据库表中的每一列都是不可分割的原子项。

2. 第二范式

每个表必须有且仅有一个数据元素为主键，其他属性需完全依赖于主键。

3. 第三范式

数据库表中的每一列都与主键直接相关，而不能间接相关。

### 范式的作用
为了消除冗余而提出的，即尽可能的减少存储成本。

但是，由于性能原因和存储成本的变化，现有的项目很多都是反范式的，通过增加冗余、聚合的手段来提升性能。