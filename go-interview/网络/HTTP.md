# 基础概念
HTTP（HyperText Transfer Protocol）是超文本传输协议的简称，运行在应用层，一般是80端口。

## URI、URL和URN
* URI：Uniform Resource Identifier，统一资源标识符；
* URL：Uniform Resource Locater，统一资源定位器；
* URN：Uniform Resource Name，统一资源名称。
URI 包含 URL 和 URN。

## 请求和响应报文
### 请求报文
由**请求行**（request line）、**请求头部**（header）、**空行**和**请求数据**，这四个部分组成
1. 请求行

由**请求方法**字段、**URL**字段和**HTTP协议版本**三个字段组成，由空格分割。比如：

Get /doc/info.html HTTP/1.1

2. 请求头部

常见的请求字段有：

Host：访问的主机名；

User-Agent：包含发出的用户信息，浏览器类型；

Accept：浏览器可接受的MIME类型；

Accept-Language：浏览器希望的语言种类；

Accept-Encoding：浏览器支持的解码方式；

If-Modified-Since：客户端通过该字段告诉服务器，资源的缓存时间；

Cookie：通过这个字段向服务器带数据，请求头信息；

Connection：处理完这次请求后是否断开连接还是继续保存连接；

3. 空行

分割请求头部和请求数据。

4. 请求数据

若方法字段是Get，则此项为空，没有数据；若方法字段为Post，则通常放置的就是要提交的数据。

### 响应报文
由**响应行**、**响应头部**、**空行**以及**响应数据**，这四个部分组成。

1. 响应行

由**HTTP协议版本**、**状态码**以及**描述**组成，比如：

HTTP/1.1 200 OK

2. 响应头部

常见字段有：

Accept-Ranges：是否接受字节范围请求；

Location：客户端重定向至指定URL；

Retry-After：对再次发起请求的时机要求；

Server：HTTP服务器的安装信息；

## HTTP请求方法
客户端发送的**请求报文**第一行为请求行，包含了请求方法字段，常见的请求方法如下：

1. GET

> 获取资源
当前网络请求中，绝大部分使用的是GET方法。

2. HEAD
> 获取报文首部

和GET方法类似，但是不返回报文主体（body）部分。主要用于确认URL的有效性以及资源更新的日期时间等。

3. POST
> 传输实体主体

POST主要用来传输数据，而GET主要用来获取资源。

4. PUT
> 上传文件

由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

5. PATCH
> 对资源进行部分修改

PUT也可以用于修改资源，但是只能完全替代原始资源，PATCH允许部分修改。

6. DELETE
> 删除文件

与PUT功能相反，并且同样不带验证机制。

7. OPTIONS
> 查询支持的方法

查询指定的URL能够支持的方法，会返回`Allow: GET, POST, HEAD, OPTIONS`这样的内容。

8. CONNECT
> 要求在与代理服务器通信时建立隧道

使用SSL协议和TLS协议把通信内容加密后经网络隧道传输。

9. TRACE
> 追踪路径

服务器会将通信路径返回给客户端。发送请求时，在Max-Forwards首部字段中填入数值，没经过一个服务器就会减1，当数值为0时就停止传输。

通常不使用，容易受到XST（跨站追踪）攻击。

## HTTP状态码
服务器返回的响应报文中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

|状态码|类别|含义|
|----|----|----|
|1xx|信息性状态码|接受的请求正在处理|
|2xx|成功状态码|请求正常处理完毕|
|3xx|重定向状态码|需要进行附加操作以完成请求|
|4xx|客户端错误状态码|服务器无法处理请求|
|5xx|服务器错误状态码|服务器处理请求出错|

### 1xx 信息
* 100 Continue：表示目前一切正常，客户端可以继续发送请求或者忽略这个响应。

### 2xx 成功
* 200 OK：表示客户端请求成功；
* 204 No Content：请求成功，但是请求的响应报文不包含实体的主体部分，一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用；
* 206 Partial Content：表示客户端进行了范围（range）请求，响应报文包含由Content-Range指定范围的实体内容，用于类似多线程下载以及断点续传。

### 3xx 重定向
* 301 Moved Permanently：永久性重定向；
* 302 Found： 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源；
* 303 See Other：和302功能相同，但要求客户端应该采用GET方法获取资源；
* 304 Not Modified：服务器内容没有更新，可以直接读取浏览器缓存；
* 307 Temporary Redirect：临时重定向，与302的含义类似，但是307要求浏览器不会把重定向请求的POST方法改成GET方法。

### 4xx 客户端错误
* 400 Bad Request：请求报文中存在语法错误；
* 401 Unauthorized：表示发送的请求需要有认证信息，如果之前已经进行过一次请求，则表示用户认证失败；
* 403 Forbidden：请求被拒绝，通常会在响应正文中给出不提供服务的原因；
* 404 Not Found：请求的资源不存在，比如输入了错误的URL。

### 5xx 服务器错误
* 500 Internal Server Error：服务器发生不可预期的错误，无法完成客户端的请求；
* 503 Service Unavailable：服务器当前无法处理请求，过一段时间可能恢复。

# 具体应用
## 连接管理
HTTP1.1与1.0最大的区别是引入了**长连接**，TCP默认不关闭，可以被多个请求复用。还有引入了**流水线机制**，客户端可以同时发送多个请求而不用等待响应返回。但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应才会处理下一个回应，就会造成**队头阻塞**问题。

1. 短连接与长连接

短连接每进行一次HTTP通信就要新建一个TCP连接，而长连接只需要建立一次TCP连接就能进行多次HTTP通信。
* 从HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用`Connection: close`；
* 在HTTP/1.0 之前默认是短连接的，如果需要使用长连接，则使用`Connection: Keep-Alive`。

2. 流水线pipeline

默认情况下，HTTP请求是按顺序发出的，下一个请求只有在当前请求受到响应之后才会被发出，可能需要等待很长时间。而流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

## Cookie
HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，当服务端需要记录用户的状态时，就需要某种机制来识别具体的用户。HTTP/1.1引入Cookie来保存状态信息。

Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，他会在浏览器之后向同一服务器再次发送请求时被带上，用于告知服务器两个请求是否来自同一个浏览器，会带来额外的性能开销。

1. 用途
* 会话状态管理，如用户登录状态、购物车等其他需要记录的信息；
* 个性化设置，如用户自定义设置、主题等；
* 浏览器行为追踪，如跟踪分析用户行为。

2. 创建过程
服务器发送的响应报文中包含`Set-Cookie`首部字段，客户端得到响应报文后把Cookie内容保存在浏览器中。
客户端之后对同一服务器发送请求时，会从浏览器中取出Cookie信息并通过Cookie请求首部字段发送给服务器。

3. 分类
* 会话期Cookie：浏览器关闭之后被自动删除，仅在会话期内有效；
* 持久性Cookie：指定过期时间（expires）或有效期（max-age）之后就成为了持久性Cookie。

```Set-Cookie: 1P_JAR=2020-07-11-07; expires=Mon, 10-Aug-2020 07:18:42 GMT; path=/; domain=.google.com; Secure; SameSite=none```

4. 作用域
Domain标识指定了哪些主机可以接受Cookie，Path标识指定了主机下的哪些路径可以接受Cookie。

5. JavaScript
浏览器通过`document.cookie`可以创建新的Cookie，也可通过该属性访问非HttpOnly标记的Cookie。

6. HttpOnly
标记为HttpOnly的Cookie不能被JavaScript脚本调用，跨站脚本攻击（XSS）通常使用JavaScript的`document.cookie`API窃取用户的Cookie信息，因此使用HttpOnly标记可以在一定程度上避免XSS攻击。
``` Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly```

7. Secure
标记为Secure的Cookie只能通过被HTTPS协议加密过的请求发送给服务端。但是即便设置了Secure标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure标记也无法为其提供确实的安全保障。

8. Session
除了可以将用户信息通过Cookie存储在用户浏览器中，也可以利用Session存储在服务器端，存储在服务器端的信息更加安全。

Session可以存储在服务器上的文件、数据库或者内存中。类似Redis这种内存型数据库中，效率会更高。

使用Session维护用户登录状态的过程如下：
* 用户进行登录始，提交包含用户名和密码的表单，放入HTTP请求报文中；
* 服务器验证该用户名和密码，如果正确则把用户信息存储到Redis中，Redis中的Key称为Session ID；
* 服务器返回的响应报文中的Set-Cookie首部字段中包含了这个Session ID，客户端收到响应报文之后将该Cookie值存入浏览器中；
* 客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到之后提取出Session ID，从Redis中取出用户信息，继续之前的业务操作。

需要注意Session ID的安全性问题，在对安全性要求极高的场景下，需要经常重新生成Session ID，或者对用户进行重新验证。

9. 浏览器禁用Cookie
此时无法使用Cookie来保存用户信息，只能使用Session，而且不能再将Session ID存放到Cookie中，而是使用URL重写技术，将Session ID作为URL的参数进行传递。

10. Cookie与Session的选择
* Cookie只能存储ASCII码字符串，而Session可以存储任意类型的数据，在考虑数据复杂性时首选Session；
* Cookie存储在浏览器中，容易被恶意查看，如果非要讲一些隐私数据存在Cookie中，可以将Cookie值进行加密，然后在服务器进行解密；
* 对于大型网站，如果将用户所有的信息都存储在Session中，开销可能比较大，不建议将所有的用户信息都存储在Session中。

## 缓存
1. 优点
* 缓解服务器压力
* 降低客户端获取资源的延迟，缓存通常位于内存中，读取缓存的速度更快；并且缓存服务器在地理位置上通常也比源服务器来的近，比如浏览器缓存。

2. 实现方法
* 让代理服务器进行缓存；
* 让客户端浏览器进行缓存。

3. Cache-Control
HTTP/1.1 通过Cache-Control首部字段来控制缓存。
* 禁止进行缓存
no-store指令规定不能对请求或响应的任何一部分进行缓存，`Cache-Control: no-store`

* 强制确认缓存
no-cache指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时，才能使用该缓存对客户端的请求进行响应：`Cache-Control: no-cache`

* 私有缓存和公共缓存

* 缓存过期机制

4. 缓存验证
通过ETag首部字段进行资源的唯一标识，可以将缓存资源的ETag放入If-None-Match首部，服务器收到该请求后，判断缓存资源的ETag值和资源的最新ETag值是否一致，如果一致则表示缓存资源有效，返回304 Not Modified。

Last-Modified首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。通常作为ETag的备用方案，如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上If-Mofified-Since来验证缓存。如果服务器对所请求的资源在给定的日期时间之后对内容进行过修改，则会将资源返回，状态码为200 OK，如果请求的资源未被修改，则返回一个不带有实体主体的304 Not Modified响应报文。

# HTTPS
HTTP存在的安全问题：
* 使用明文进行通信，内容可能会被窃听；
* 不验证通信方的身份，通信方的身份有可能遭遇伪装；
* 无法验证报文的完整性，报文有可能遭篡改。

HTTPS是由SSL协议+HTTP协议构建的可进行加密传输和身份认证的网络协议，工作在443端口。先使用非对称密钥加密方式，传输对称密钥加密方式需要的Secret Key，从而保证安全性；获取到Secret Key后，再使用对称密钥加密方式进行通信，从而保证效率。

认证过程如下：
1. 客户端发送SSL版本信息给服务端；
2. 服务端给客户端返回SSL版本、服务器公钥等信息；
3. 客户端校验服务端证书是否合法，合法的话就发送自己可支持的对称加密方案给服务端，供其选择；
4. 服务端选择加密程度高的加密方式；
5. 将选择好的加密方式以明文方式发送给客户端；
6. 客户端产生随机码，作为对称加密密钥，使用服务端公钥进行加密后，发送给服务端；
7. 服务端使用私钥对加密信息进行解密，获得对称加密的密钥；
8. 开始对称加密的通信。

HTTPS的缺陷：
* 加密解密所需时间较长；
* 证书费用高昂。

# HTTP/2.0
## HTTP/1.x缺陷
HTTP/1.x实现简单是以牺牲性能为代价的：
* 客户端需要使用多个连接才能实现并发和缩短延迟；
* 不压缩请求和响应首部，导致不必要的网络流量；
* 不支持有效的资源优先级，致使底层TCP连接的利用率低下。

## HTTP/2.0引入的新特性
### 二进制分帧层
HTTP/2.0将报文分成HEADERS帧和DATA帧，都是二进制格式的。

在通信过程中，只会有一个TCP连接存在，它承载了任意数量的双向数据流（Stream），
* 一个数据流（Stream）会有一个唯一标识符和可选的优先级信息，用于承载双向信息；
* 消息（Message）是与逻辑请求或响应对应的完整的一系列帧；
* 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

### 服务端推送
HTTP/2.0在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发送请求了。

### 首部压缩
HTTP/1.1的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。

另外，HTTP/2.0使用Huffman编码对首部字段进行压缩。

# GET和POST比较
## 作用
GET一般用来获取资源，而POST用来传输实体主体。

## 参数
GET和POST的请求都能使用额外的参数，但是GET的参数是以查询字符串出现在URL中的，而POST的参数存储在实体主体中。GET参数暴露在URL中，同时也受URL长度的限制。

URL只支持ASCII码，因此GET的参数中如果存在中文等字符就需要先进行编码，而POST参数支持标准字符集。

## 安全
安全的HTTP方法不会改变服务器状态，也就是说只是可读的。

GET方法是安全的，而POST却不是，因为POST的目的是传送实体主体内容，上传成功之后，服务器可能把该内容存储在数据库中，服务器状态也就发生了变化。

安全的方法有：GET、HEAD和OPTIONS。
不安全的方法有：POST、PUT、PATCH和DELETE。

## 幂等性
幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。幂等方法不应该具有副作用。

所有的安全方法都是幂等的，在正确实现的条件下，GET、HEAD、PUT和DELETE等方法都是幂等的，而POST方法则不是。

## 可缓存
