1. 协助部分业务从传统CICD向云原生CICD的迁移，从Jenkins、Travis到Prow、Tekton。

## 研发流程
目前研发流程主要基于jenkins，jira的协作构成：

研发过程包括开发 -> 测试 -> 发布上线整个过程

开发测试流程如下：

新建 -> 开发 -> 审核 -> 测试 -> 发布 -> 完成 / 关闭

新建|开发|审核|测试|发布|完成/关闭
---|---|---|---|---|---
负责人新增或者排期缺陷/任务|开发人员coding，提交PR|开发人员指派给code review人员|测试人员选择相应模块的pipeline进行持续集成|开发人员根据上线情况建立发布issue给SRE|部署上线成功，验证通过
添加issue到jira|测试人员为新功能或者bug补充测试用例|Travis CI check|测试通过，开发人员执行prudoct pipeline|回归测试专用job|测试人员将状态改为关闭

## pipeline介绍
build develop branch -> deploy to cs -> smoke test -> business test -> distribute package to jumpbox

冒烟测试：指的是对系统的基本功能和主要流程进行简单的测试，确保系统能跑起来，才进行下一步流程。

回归测试：是软件维护阶段对软件修改后进行的测试，只要软件功能发生了变化，就必须重新测试现有的功能，以便确定修改是否达到了预期的目的，修改是否损害了原来正常的功能。

## Jenkins
Jenkins是一个广泛用于持续构建的可视化Web工具。

在Jenkins中，每一个持续集成任务都称作Job，Job就是一系列具体动作的集合，如：提交代码、构建项目、测试和部署环境等。

缺点主要是在容器化越来越流行的趋势下，流水线对于容器化应用的持续集成的支持也很重要，而Jenkins在这方面做的不好。

## Travis
只支持Github等少数的代码托管平台，而Jenkins通过已有插件支持可以很方便的从任意基于git和svn等版本控制系统的代码托管平台拉取代码。

使用Travis CI一般是通过编写travis.yaml的方式，而Jenkins可以通过web UI的方式来配置。

## Prow
基于GitHub Webhook，

核心组件：
1. Hook，最核心的组件，一个无状态服务，开启/hook路由接收GitHub Webhook events，根据event type分发任务到不同的plugin中执行。plugin负责触发jobs、实现/foo样式命令的chat-ops、通知到slock等工作。可以配置不同的repo使用不同的plugins。
2. Plank，prowjob controller，负责管理在kubernetes中job的执行和生命周期。
3. Deck，一个dashboard，展示job、PR的状态信息，还有各种plugins的帮助信息。
4. Horologium：根据策略创建Periodics类型的job。
5. Sinker：定时清理旧的job和相关联的job状态是finished的job，清理周期可以配置。

自动化和入PR
* tide：自动重新测试PR，并根据预先设定的合并标准，自动化合并PR。

## Tekton
Tekton是一套构建CICD系统的框架，基于Tekton可以设计出各种构建部署流水线。


# 云原生
DevOps + 持续交付 + 微服务 + 容器化

采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。

## Docker
docker与虚拟化技术的对比如下：
1. KVM等虚拟化技术是在操作系统级别上进行虚拟和隔离，每一个虚拟机都是独立的OS。
2. 而docker是在同一个操作系统中，实现了轻量级的虚拟化，本质上是同一个操作系统中的进程隔离。
3. docker实现了同一个软件发布，在不同的平台上运行。

## Kubernetes
容器编排系统，主要解决以下问题：
1. 分布式容器应用的可靠性，在服务器或容器应用出现问题的情况下，自动感知，自动将容器应用在集群中的其他机器里重新运行起来；
2. 分布式容器应用的可拓展性，通过启动相同的容器应用，自动的提升应用的负载支撑能力。

## 微服务
微服务是可以独立部署的、小的、自治的业务组件，彼此之间通过消息进行交互。微服务的组件可以按需独立伸缩，具备容错和故障恢复能力。

微服务架构的优势有：
1. 支持快速上线，由于业务组件的自治性和独立性，新的功能和应用能够迅速的发布上线，而不用担心对系统其他功能带来大范围的影响和涉及。
2. 支持独立扩容和恢复，支持针对性的对应用中的某些服务进行扩容，解决性能的瓶颈，可以独立替换或恢复微服务中的某个组件。

## DevOps
DevOps是Development和Operation的组合，重视开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试和发布更加迅速和可靠。


2. 开发并部署bot服务
服务端开发背景，开发流程和遇到的难点。
## 开发背景
围绕公司业务需求中的痛点，解决
## 开发流程
for _, repo := range repos{
    go func(repo){
        go func(){
            writeGithubComment(prs)
        }()
        go func(){
            writeJiraComment(prs)
        }()
    }()
}
## 难点
### 定时器
time.NewTicker()，c是一个缓冲空间为1的channel，当定时器超时时，就会将当前时间放入通道中，如果通道满了，不能放入就丢弃。总之，不会阻塞定时器的内部调度。外部在使用时，只要从Ticker.C这个通道中不断读取即可，能取到值时，说明发生过超时，执行相应业务即可。

### 同步原语与锁：
sync.WaitGroup，将原本顺序执行的代码在多个Goroutine中并发执行，加快程序处理的速度。

对外暴露的三个方法sync.WaitGroup.Add、sync.WaitGroup.Done、sync.WaitGroup.Wait。当 sync.WaitGroup 的计数器归零时，陷入睡眠状态的 Goroutine 就被唤醒，上述方法会立刻返回。

sync.Map{}，golang里的map在并发情况下，只读是线程安全的，同时写线程不安全，用sync.Map{}是为了并发安全和高效。sync.Map{}通过读写分离，降低锁时间来提高效率，缺点：不适合大量写的场景。

sync.Map{}的实现原理可概括为：
1. 通过read和dirty两个字段将读写分离，读的数据存在只读字段read上，将最新写入的数据则存在dirty字段上；
2. 读取时会先查询read，不存在再查询dirty，写入时则只写入dirty；
3. 读取read并不需要加锁，而读和写dirty都需要加锁；
4. 统计read被穿透的次数，超过一定次数将dirty数据同步在read上；
5. 对于删除数据则直接通过标记来延迟删除。

线程安全：当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

### defer执行顺序问题
1. defer关键字的调用时机以及多次调用defer时的执行顺序，

	作用域：向defer关键字传入的函数会在函数返回之前运行，不是在退出代码块的作用域时执行，而是在当前函数和方法返回之前被调用。

	对于多次调用defer时，会倒序执行所有向defer关键字中传入的表达式，相当于栈的思想，后入先出。
2. 预计算参数
	Go语言中所有的函数调用都是传值的，defer虽然是关键字，但也继承了这个特性。defer关键字在调用时，会立刻对函数中引用的外部参数进行拷贝。要解决这个问题可以向defer中传入匿名函数，这时候拷贝的是函数指针。

### Goroutine
1. 内存分配
动态栈，每一个OS线程都有一个固定大小的内存块（一般是2MB）来做栈，该栈会用来存储当前正在被调用或挂起的函数的内部变量。

相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和线程一样，会保存其活跃或挂起的函数调用的本地变量。但是goroutine的栈并不是固定的，其大小会根据需要动态地伸缩，最大值可以到1GB。

2. 调度
线程被操作系统内核调度，每几毫秒，一个硬件计时器会中断处理器，调用一个叫做scheduler的内核函数。该函数会挂起当前执行的线程并保存内存中它的寄存器内容，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。

线程被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，需要几次内存访问，并会增加运行的CPU周期。

GO调度器不是用一个硬件定时器，而是由Go语言本身进行调度，有专门的调度器。而这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。

### Channel
实现对同时访问库的数目限制。

goroutine是Go语言程序的并发体，那么channels则是它们之间的通信机制，一个channel是一个通信机制，可以让一个goroutine通过它给另一个goroutine发送值信息。

无缓存的channel和有缓存的channel。


## HEVC视频编解码
CTU划分 -> 帧间/帧内预测 -> transform（转换） -> Quantization（量化）-> 熵编码（Entropy coding）。

1. CTU划分
CTU单元64x64，32x32，16x16，按照四叉树单元划分。

CTU分解成若干CU，同一层次的CU必须是同一尺寸的4个方块，最多有四层分解，即64x64，32x32，16x16，8x8.如果不分解，则这个CTU仅包含一个CU。CU是决定进行帧内预测还是帧间预测的单元，CU还可以分解成更小的预测单元PU。

PU是进行预测运算的基本单元，包括帧内和帧间两类，CU划分为PU有八种划分模式。

2. 帧间/帧内预测
33种帧内预测模式，帧间预测模式，inter模式、skip模式和merge模式。

3. 变换和量化
是在整数DCT变换时一并完成的，采用的是率失真优化的量化技术。

4. 熵编码
CABAC进行熵编码。

完整过程如下：
输入原始视频序列，按照LCU（最大编码单元）分为不重叠的矩形块。对于每个LCU，编码器选择合适的CU四叉树划分方法。对于每个不再继续划分的CU，编码器选择合适的预测方式进行预测。经过预测后，原始信号和预测信号的差值称作残差信号，残差信号经过变换量化后传递到解码端。

解码端的预测值加上反变换和反量化后重建的残差值构成了重建值，重建值经过滤波（包括去块效应滤波和SAO）处理后，构成最终的输出图片。